import {
  AptosParserRepo,
  getTypeTagFullname,
  StructTag,
  parseTypeTagOrThrow,
  u8,
  u64,
  u128,
  print,
  strToU8,
  u8str,
  DummyCache,
  ActualStringClass,
  sendPayloadTx,
  getSimulationKeys,
} from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Coin_list from "./coin_list";
import * as Econia from "./econia";
import * as Hippo_aggregator from "./hippo_aggregator";
import * as Hippo_swap from "./hippo_swap";

export const readConfig = (program: Command) => {
  const { config, profile } = program.opts();
  const ymlContent = fs.readFileSync(config, { encoding: "utf-8" });
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return { client, account };
};

const program = new Command();

program
  .name("yarn cli")
  .description("Move TS CLI generated by move-to-ts")
  .requiredOption(
    "-c, --config <path>",
    'path to your aptos config.yml (generated with "aptos init")'
  )
  .option("-p, --profile <PROFILE>", "aptos config profile to use", "default");

const coin_list_add_extension = async (
  CoinType: string,
  key: string,
  value: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const key_ = new ActualStringClass(
    { bytes: strToU8(key) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const value_ = new ActualStringClass(
    { bytes: strToU8(value) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const payload = Coin_list.Coin_list.buildPayload_add_extension(key_, value_, [
    CoinType_,
  ]);
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:add-extension")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<key>")
  .argument("<value>")
  .action(coin_list_add_extension);

const coin_list_add_to_list = async (CoinType: string) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const payload = Coin_list.Coin_list.buildPayload_add_to_list([CoinType_]);
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:add-to-list")
  .description("")
  .argument("<TYPE_CoinType>")
  .action(coin_list_add_to_list);

const coin_list_add_to_registry_by_admin = async (
  CoinType: string,
  name: string,
  symbol: string,
  coingecko_id: string,
  logo_url: string,
  project_url: string,
  is_update: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const name_ = new ActualStringClass(
    { bytes: strToU8(name) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const symbol_ = new ActualStringClass(
    { bytes: strToU8(symbol) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const coingecko_id_ = new ActualStringClass(
    { bytes: strToU8(coingecko_id) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const logo_url_ = new ActualStringClass(
    { bytes: strToU8(logo_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const project_url_ = new ActualStringClass(
    { bytes: strToU8(project_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const is_update_ = is_update == "true";
  const payload = Coin_list.Coin_list.buildPayload_add_to_registry_by_admin(
    name_,
    symbol_,
    coingecko_id_,
    logo_url_,
    project_url_,
    is_update_,
    [CoinType_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:add-to-registry-by-admin")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<name>")
  .argument("<symbol>")
  .argument("<coingecko_id>")
  .argument("<logo_url>")
  .argument("<project_url>")
  .argument("<is_update>")
  .action(coin_list_add_to_registry_by_admin);

const coin_list_add_to_registry_by_signer = async (
  CoinType: string,
  name: string,
  symbol: string,
  coingecko_id: string,
  logo_url: string,
  project_url: string,
  is_update: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const name_ = new ActualStringClass(
    { bytes: strToU8(name) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const symbol_ = new ActualStringClass(
    { bytes: strToU8(symbol) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const coingecko_id_ = new ActualStringClass(
    { bytes: strToU8(coingecko_id) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const logo_url_ = new ActualStringClass(
    { bytes: strToU8(logo_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const project_url_ = new ActualStringClass(
    { bytes: strToU8(project_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const is_update_ = is_update == "true";
  const payload = Coin_list.Coin_list.buildPayload_add_to_registry_by_signer(
    name_,
    symbol_,
    coingecko_id_,
    logo_url_,
    project_url_,
    is_update_,
    [CoinType_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:add-to-registry-by-signer")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<name>")
  .argument("<symbol>")
  .argument("<coingecko_id>")
  .argument("<logo_url>")
  .argument("<project_url>")
  .argument("<is_update>")
  .action(coin_list_add_to_registry_by_signer);

const coin_list_create_list = async () => {
  const { client, account } = readConfig(program);

  const payload = Coin_list.Coin_list.buildPayload_create_list();
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:create-list")
  .description("")

  .action(coin_list_create_list);

const coin_list_drop_extension = async (
  CoinType: string,
  key: string,
  value: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const key_ = new ActualStringClass(
    { bytes: strToU8(key) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const value_ = new ActualStringClass(
    { bytes: strToU8(value) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const payload = Coin_list.Coin_list.buildPayload_drop_extension(
    key_,
    value_,
    [CoinType_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:drop-extension")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<key>")
  .argument("<value>")
  .action(coin_list_drop_extension);

const coin_list_initialize = async () => {
  const { client, account } = readConfig(program);

  const payload = Coin_list.Coin_list.buildPayload_initialize();
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:initialize")
  .description("")

  .action(coin_list_initialize);

const coin_list_remove_from_list = async (CoinType: string) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const payload = Coin_list.Coin_list.buildPayload_remove_from_list([
    CoinType_,
  ]);
  await sendPayloadTx(client, account, payload);
};

program
  .command("coin-list:remove-from-list")
  .description("")
  .argument("<TYPE_CoinType>")
  .action(coin_list_remove_from_list);

const devnet_coins_deploy = async () => {
  const { client, account } = readConfig(program);

  const payload = Coin_list.Devnet_coins.buildPayload_deploy();
  await sendPayloadTx(client, account, payload);
};

program
  .command("devnet-coins:deploy")
  .description("Register devnet coins")

  .action(devnet_coins_deploy);

const devnet_coins_mint_to_wallet = async (
  CoinType: string,
  amount: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const payload = Coin_list.Devnet_coins.buildPayload_mint_to_wallet(amount_, [
    CoinType_,
  ]);
  await sendPayloadTx(client, account, payload);
};

program
  .command("devnet-coins:mint-to-wallet")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<amount>")
  .action(devnet_coins_mint_to_wallet);

const aggregator_initialize = async () => {
  const { client, account } = readConfig(program);

  const payload = Hippo_aggregator.Aggregator.buildPayload_initialize();
  await sendPayloadTx(client, account, payload);
};

program
  .command("aggregator:initialize")
  .description("")

  .action(aggregator_initialize);

const aggregator_one_step_route = async (
  X: string,
  Y: string,
  E: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  x_in: string,
  y_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const E_ = parseTypeTagOrThrow(E);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_aggregator.Aggregator.buildPayload_one_step_route(
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    x_in_,
    y_min_out_,
    [X_, Y_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("aggregator:one-step-route")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_E>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<x_in>")
  .argument("<y_min_out>")
  .action(aggregator_one_step_route);

const aggregator_three_step_route = async (
  X: string,
  Y: string,
  Z: string,
  M: string,
  E1: string,
  E2: string,
  E3: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_dex_type: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  third_dex_type: string,
  third_pool_type: string,
  third_is_x_to_y: string,
  x_in: string,
  m_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const M_ = parseTypeTagOrThrow(M);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u8(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const m_min_out_ = u64(m_min_out);
  const payload = Hippo_aggregator.Aggregator.buildPayload_three_step_route(
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    second_dex_type_,
    second_pool_type_,
    second_is_x_to_y_,
    third_dex_type_,
    third_pool_type_,
    third_is_x_to_y_,
    x_in_,
    m_min_out_,
    [X_, Y_, Z_, M_, E1_, E2_, E3_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("aggregator:three-step-route")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_M>")
  .argument("<TYPE_E1>")
  .argument("<TYPE_E2>")
  .argument("<TYPE_E3>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_dex_type>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<third_dex_type>")
  .argument("<third_pool_type>")
  .argument("<third_is_x_to_y>")
  .argument("<x_in>")
  .argument("<m_min_out>")
  .action(aggregator_three_step_route);

const aggregator_two_step_route = async (
  X: string,
  Y: string,
  Z: string,
  E1: string,
  E2: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_dex_type: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  x_in: string,
  z_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const z_min_out_ = u64(z_min_out);
  const payload = Hippo_aggregator.Aggregator.buildPayload_two_step_route(
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    second_dex_type_,
    second_pool_type_,
    second_is_x_to_y_,
    x_in_,
    z_min_out_,
    [X_, Y_, Z_, E1_, E2_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("aggregator:two-step-route")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_E1>")
  .argument("<TYPE_E2>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_dex_type>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<x_in>")
  .argument("<z_min_out>")
  .action(aggregator_two_step_route);

const coins_init_coin_types = async () => {
  const { client, account } = readConfig(program);

  const payload = Econia.Coins.buildPayload_init_coin_types();
  await sendPayloadTx(client, account, payload);
};

program
  .command("coins:init-coin-types")
  .description("")

  .action(coins_init_coin_types);

const coins_mint = async (CoinType: string, amount: string) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const payload = Econia.Coins.buildPayload_mint(amount_, [CoinType_]);
  await sendPayloadTx(client, account, payload);
};

program
  .command("coins:mint")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<amount>")
  .action(coins_mint);

const cp_scripts_add_liquidity_script = async (
  X: string,
  Y: string,
  amount_x: string,
  amount_y: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const amount_x_ = u64(amount_x);
  const amount_y_ = u64(amount_y);
  const payload = Hippo_swap.Cp_scripts.buildPayload_add_liquidity_script(
    amount_x_,
    amount_y_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("cp-scripts:add-liquidity-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<amount_x>")
  .argument("<amount_y>")
  .action(cp_scripts_add_liquidity_script);

const cp_scripts_create_new_pool_script = async (
  X: string,
  Y: string,
  fee_to: string,
  fee_on: string,
  lp_name: string,
  lp_symbol: string,
  lp_logo_url: string,
  lp_project_url: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const fee_to_ = new HexString(fee_to);
  const fee_on_ = fee_on == "true";
  const lp_name_ = strToU8(lp_name);
  const lp_symbol_ = strToU8(lp_symbol);
  const lp_logo_url_ = strToU8(lp_logo_url);
  const lp_project_url_ = strToU8(lp_project_url);
  const payload = Hippo_swap.Cp_scripts.buildPayload_create_new_pool_script(
    fee_to_,
    fee_on_,
    lp_name_,
    lp_symbol_,
    lp_logo_url_,
    lp_project_url_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("cp-scripts:create-new-pool-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<fee_to>")
  .argument("<fee_on>")
  .argument("<lp_name>")
  .argument("<lp_symbol>")
  .argument("<lp_logo_url>")
  .argument("<lp_project_url>")
  .action(cp_scripts_create_new_pool_script);

const cp_scripts_mock_deploy_script = async () => {
  const { client, account } = readConfig(program);

  const payload = Hippo_swap.Cp_scripts.buildPayload_mock_deploy_script();
  await sendPayloadTx(client, account, payload);
};

program
  .command("cp-scripts:mock-deploy-script")
  .description("")

  .action(cp_scripts_mock_deploy_script);

const cp_scripts_remove_liquidity_script = async (
  X: string,
  Y: string,
  liquidity: string,
  amount_x_min: string,
  amount_y_min: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const liquidity_ = u64(liquidity);
  const amount_x_min_ = u64(amount_x_min);
  const amount_y_min_ = u64(amount_y_min);
  const payload = Hippo_swap.Cp_scripts.buildPayload_remove_liquidity_script(
    liquidity_,
    amount_x_min_,
    amount_y_min_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("cp-scripts:remove-liquidity-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<liquidity>")
  .argument("<amount_x_min>")
  .argument("<amount_y_min>")
  .action(cp_scripts_remove_liquidity_script);

const cp_scripts_swap_script = async (
  X: string,
  Y: string,
  x_in: string,
  y_in: string,
  x_min_out: string,
  y_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const x_in_ = u64(x_in);
  const y_in_ = u64(y_in);
  const x_min_out_ = u64(x_min_out);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_swap.Cp_scripts.buildPayload_swap_script(
    x_in_,
    y_in_,
    x_min_out_,
    y_min_out_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("cp-scripts:swap-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<x_in>")
  .argument("<y_in>")
  .argument("<x_min_out>")
  .argument("<y_min_out>")
  .action(cp_scripts_swap_script);

const devnet_mock_deploy_econia = async () => {
  const { client, account } = readConfig(program);

  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_econia();
  await sendPayloadTx(client, account, payload);
};

program
  .command("devnet:mock-deploy-econia")
  .description("Create BTC-USDC pool on econia and add liquidity")

  .action(devnet_mock_deploy_econia);

const devnet_mock_deploy_pontem = async () => {
  const { client, account } = readConfig(program);

  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_pontem();
  await sendPayloadTx(client, account, payload);
};

program
  .command("devnet:mock-deploy-pontem")
  .description("Create BTC-USDC pool on pontem and add liquidity")

  .action(devnet_mock_deploy_pontem);

const init_init_econia = async () => {
  const { client, account } = readConfig(program);

  const payload = Econia.Init.buildPayload_init_econia();
  await sendPayloadTx(client, account, payload);
};

program
  .command("init:init-econia")
  .description("")

  .action(init_init_econia);

const market_cancel_limit_order_user = async (
  B: string,
  Q: string,
  E: string,
  host: string,
  side: string,
  order_id: string
) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const side_ = side == "true";
  const order_id_ = u128(order_id);
  const payload = Econia.Market.buildPayload_cancel_limit_order_user(
    host_,
    side_,
    order_id_,
    [B_, Q_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("market:cancel-limit-order-user")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .argument("<host>")
  .argument("<side>")
  .argument("<order_id>")
  .action(market_cancel_limit_order_user);

const market_fill_market_order_user = async (
  B: string,
  Q: string,
  E: string,
  host: string,
  style: string,
  max_base_parcels: string,
  max_quote_units: string
) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const style_ = style == "true";
  const max_base_parcels_ = u64(max_base_parcels);
  const max_quote_units_ = u64(max_quote_units);
  const payload = Econia.Market.buildPayload_fill_market_order_user(
    host_,
    style_,
    max_base_parcels_,
    max_quote_units_,
    [B_, Q_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("market:fill-market-order-user")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .argument("<host>")
  .argument("<style>")
  .argument("<max_base_parcels>")
  .argument("<max_quote_units>")
  .action(market_fill_market_order_user);

const market_place_limit_order_user = async (
  B: string,
  Q: string,
  E: string,
  host: string,
  side: string,
  base_parcels: string,
  price: string
) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const side_ = side == "true";
  const base_parcels_ = u64(base_parcels);
  const price_ = u64(price);
  const payload = Econia.Market.buildPayload_place_limit_order_user(
    host_,
    side_,
    base_parcels_,
    price_,
    [B_, Q_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("market:place-limit-order-user")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .argument("<host>")
  .argument("<side>")
  .argument("<base_parcels>")
  .argument("<price>")
  .action(market_place_limit_order_user);

const market_register_market = async (B: string, Q: string, E: string) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const payload = Econia.Market.buildPayload_register_market([B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
};

program
  .command("market:register-market")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .action(market_register_market);

const piece_swap_script_add_liquidity_script = async (
  X: string,
  Y: string,
  amount_x: string,
  amount_y: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const amount_x_ = u64(amount_x);
  const amount_y_ = u64(amount_y);
  const payload =
    Hippo_swap.Piece_swap_script.buildPayload_add_liquidity_script(
      amount_x_,
      amount_y_,
      [X_, Y_]
    );
  await sendPayloadTx(client, account, payload);
};

program
  .command("piece-swap-script:add-liquidity-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<amount_x>")
  .argument("<amount_y>")
  .action(piece_swap_script_add_liquidity_script);

const piece_swap_script_create_new_pool_script = async (
  X: string,
  Y: string,
  lp_name: string,
  lp_symbol: string,
  k: string,
  w1_numerator: string,
  w1_denominator: string,
  w2_numerator: string,
  w2_denominator: string,
  swap_fee_per_million: string,
  protocol_fee_share_per_thousand: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const lp_name_ = strToU8(lp_name);
  const lp_symbol_ = strToU8(lp_symbol);
  const k_ = u128(k);
  const w1_numerator_ = u128(w1_numerator);
  const w1_denominator_ = u128(w1_denominator);
  const w2_numerator_ = u128(w2_numerator);
  const w2_denominator_ = u128(w2_denominator);
  const swap_fee_per_million_ = u64(swap_fee_per_million);
  const protocol_fee_share_per_thousand_ = u64(protocol_fee_share_per_thousand);
  const payload =
    Hippo_swap.Piece_swap_script.buildPayload_create_new_pool_script(
      lp_name_,
      lp_symbol_,
      k_,
      w1_numerator_,
      w1_denominator_,
      w2_numerator_,
      w2_denominator_,
      swap_fee_per_million_,
      protocol_fee_share_per_thousand_,
      [X_, Y_]
    );
  await sendPayloadTx(client, account, payload);
};

program
  .command("piece-swap-script:create-new-pool-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<lp_name>")
  .argument("<lp_symbol>")
  .argument("<k>")
  .argument("<w1_numerator>")
  .argument("<w1_denominator>")
  .argument("<w2_numerator>")
  .argument("<w2_denominator>")
  .argument("<swap_fee_per_million>")
  .argument("<protocol_fee_share_per_thousand>")
  .action(piece_swap_script_create_new_pool_script);

const piece_swap_script_mock_deploy_script = async () => {
  const { client, account } = readConfig(program);

  const payload =
    Hippo_swap.Piece_swap_script.buildPayload_mock_deploy_script();
  await sendPayloadTx(client, account, payload);
};

program
  .command("piece-swap-script:mock-deploy-script")
  .description("")

  .action(piece_swap_script_mock_deploy_script);

const piece_swap_script_remove_liquidity_script = async (
  X: string,
  Y: string,
  liquidity: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const liquidity_ = u64(liquidity);
  const payload =
    Hippo_swap.Piece_swap_script.buildPayload_remove_liquidity_script(
      liquidity_,
      [X_, Y_]
    );
  await sendPayloadTx(client, account, payload);
};

program
  .command("piece-swap-script:remove-liquidity-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<liquidity>")
  .action(piece_swap_script_remove_liquidity_script);

const piece_swap_script_swap_script = async (
  X: string,
  Y: string,
  x_in: string,
  y_in: string,
  x_min_out: string,
  y_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const x_in_ = u64(x_in);
  const y_in_ = u64(y_in);
  const x_min_out_ = u64(x_min_out);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_swap.Piece_swap_script.buildPayload_swap_script(
    x_in_,
    y_in_,
    x_min_out_,
    y_min_out_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("piece-swap-script:swap-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<x_in>")
  .argument("<y_in>")
  .argument("<x_min_out>")
  .argument("<y_min_out>")
  .action(piece_swap_script_swap_script);

const router_three_step_route_script = async (
  X: string,
  Y: string,
  Z: string,
  A: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  third_pool_type: string,
  third_is_x_to_y: string,
  x_in: string,
  a_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const A_ = parseTypeTagOrThrow(A);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const third_pool_type_ = u8(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const a_min_out_ = u64(a_min_out);
  const payload = Hippo_swap.Router.buildPayload_three_step_route_script(
    first_pool_type_,
    first_is_x_to_y_,
    second_pool_type_,
    second_is_x_to_y_,
    third_pool_type_,
    third_is_x_to_y_,
    x_in_,
    a_min_out_,
    [X_, Y_, Z_, A_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("router:three-step-route-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_A>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<third_pool_type>")
  .argument("<third_is_x_to_y>")
  .argument("<x_in>")
  .argument("<a_min_out>")
  .action(router_three_step_route_script);

const router_two_step_route_script = async (
  X: string,
  Y: string,
  Z: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  x_in: string,
  z_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const z_min_out_ = u64(z_min_out);
  const payload = Hippo_swap.Router.buildPayload_two_step_route_script(
    first_pool_type_,
    first_is_x_to_y_,
    second_pool_type_,
    second_is_x_to_y_,
    x_in_,
    z_min_out_,
    [X_, Y_, Z_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("router:two-step-route-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<x_in>")
  .argument("<z_min_out>")
  .action(router_two_step_route_script);

const stable_curve_scripts_add_liquidity = async (
  X: string,
  Y: string,
  amount_x: string,
  amount_y: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const amount_x_ = u64(amount_x);
  const amount_y_ = u64(amount_y);
  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_add_liquidity(
    amount_x_,
    amount_y_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("stable-curve-scripts:add-liquidity")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<amount_x>")
  .argument("<amount_y>")
  .action(stable_curve_scripts_add_liquidity);

const stable_curve_scripts_mock_deploy_script = async () => {
  const { client, account } = readConfig(program);

  const payload =
    Hippo_swap.Stable_curve_scripts.buildPayload_mock_deploy_script();
  await sendPayloadTx(client, account, payload);
};

program
  .command("stable-curve-scripts:mock-deploy-script")
  .description("")

  .action(stable_curve_scripts_mock_deploy_script);

const stable_curve_scripts_remove_liquidity = async (
  X: string,
  Y: string,
  liquidity: string,
  min_amount_x: string,
  min_amount_y: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const liquidity_ = u64(liquidity);
  const min_amount_x_ = u64(min_amount_x);
  const min_amount_y_ = u64(min_amount_y);
  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_remove_liquidity(
    liquidity_,
    min_amount_x_,
    min_amount_y_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("stable-curve-scripts:remove-liquidity")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<liquidity>")
  .argument("<min_amount_x>")
  .argument("<min_amount_y>")
  .action(stable_curve_scripts_remove_liquidity);

const stable_curve_scripts_swap_script = async (
  X: string,
  Y: string,
  x_in: string,
  y_in: string,
  x_min_out: string,
  y_min_out: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const x_in_ = u64(x_in);
  const y_in_ = u64(y_in);
  const x_min_out_ = u64(x_min_out);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_swap_script(
    x_in_,
    y_in_,
    x_min_out_,
    y_min_out_,
    [X_, Y_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("stable-curve-scripts:swap-script")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<x_in>")
  .argument("<y_in>")
  .argument("<x_min_out>")
  .argument("<y_min_out>")
  .action(stable_curve_scripts_swap_script);

const user_deposit_collateral_coinstore = async (
  B: string,
  Q: string,
  E: string,
  custodian_id: string,
  base: string,
  amount: string
) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const base_ = base == "true";
  const amount_ = u64(amount);
  const payload = Econia.User.buildPayload_deposit_collateral_coinstore(
    custodian_id_,
    base_,
    amount_,
    [B_, Q_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("user:deposit-collateral-coinstore")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .argument("<custodian_id>")
  .argument("<base>")
  .argument("<amount>")
  .action(user_deposit_collateral_coinstore);

const user_register_market_account = async (
  B: string,
  Q: string,
  E: string,
  custodian_id: string
) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const payload = Econia.User.buildPayload_register_market_account(
    custodian_id_,
    [B_, Q_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("user:register-market-account")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .argument("<custodian_id>")
  .action(user_register_market_account);

const user_withdraw_collateral_coinstore = async (
  B: string,
  Q: string,
  E: string,
  custodian_id: string,
  base: string,
  amount: string
) => {
  const { client, account } = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const base_ = base == "true";
  const amount_ = u64(amount);
  const payload = Econia.User.buildPayload_withdraw_collateral_coinstore(
    custodian_id_,
    base_,
    amount_,
    [B_, Q_, E_]
  );
  await sendPayloadTx(client, account, payload);
};

program
  .command("user:withdraw-collateral-coinstore")
  .description("")
  .argument("<TYPE_B>")
  .argument("<TYPE_Q>")
  .argument("<TYPE_E>")
  .argument("<custodian_id>")
  .argument("<base>")
  .argument("<amount>")
  .action(user_withdraw_collateral_coinstore);

const volume_initialize = async (poster: string) => {
  const { client, account } = readConfig(program);
  const poster_ = new HexString(poster);
  const payload = Hippo_aggregator.Volume.buildPayload_initialize(poster_);
  await sendPayloadTx(client, account, payload);
};

program
  .command("volume:initialize")
  .description("")
  .argument("<poster>")
  .action(volume_initialize);

const volume_set_poster = async (new_poster: string) => {
  const { client, account } = readConfig(program);
  const new_poster_ = new HexString(new_poster);
  const payload = Hippo_aggregator.Volume.buildPayload_set_poster(new_poster_);
  await sendPayloadTx(client, account, payload);
};

program
  .command("volume:set-poster")
  .description("")
  .argument("<new_poster>")
  .action(volume_set_poster);

const coin_list_fetch_all_registered_coin_info = async () => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Coin_list.Coin_list.query_fetch_all_registered_coin_info(
    client,
    getSimulationKeys(account),
    repo,
    []
  );
  print(value);
};

program
  .command("coin-list:query-fetch-all-registered-coin-info")

  .action(coin_list_fetch_all_registered_coin_info);

const coin_list_fetch_full_list = async (list_owner_addr: string) => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Coin_list.Coin_list.query_fetch_full_list(
    client,
    getSimulationKeys(account),
    repo,
    new HexString(list_owner_addr),
    []
  );
  print(value);
};

program
  .command("coin-list:query-fetch-full-list")
  .argument("<list_owner_addr>")
  .action(coin_list_fetch_full_list);

const utils_get_pool_list = async () => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Hippo_swap.Utils.query_get_pool_list(
    client,
    getSimulationKeys(account),
    repo,
    []
  );
  print(value);
};

program
  .command("utils:query-get-pool-list")

  .action(utils_get_pool_list);

const volume_fetch_volume = async () => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Hippo_aggregator.Volume.query_fetch_volume(
    client,
    getSimulationKeys(account),
    repo,
    []
  );
  print(value);
};

program
  .command("volume:query-fetch-volume")

  .action(volume_fetch_volume);

program.parse();
