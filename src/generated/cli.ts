
import { AptosParserRepo, getTypeTagFullname, StructTag, parseTypeTagOrThrow, u8, u64, u128, print, strToU8, u8str, DummyCache } from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Coin_registry from './coin_registry';
import * as Econia from './econia';
import * as Hippo_aggregator from './hippo_aggregator';
import * as Hippo_swap from './hippo_swap';

export const readConfig = (program: Command) => {
  const {config, profile} = program.opts();
  const ymlContent = fs.readFileSync(config, {encoding: "utf-8"});
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return {client, account};
}

export async function sendPayloadTx(
  client: AptosClient,
  account: AptosAccount,
  payload: Types.TransactionPayload,
  max_gas=1000
){
  const txnRequest = await client.generateTransaction(account.address(), payload, {max_gas_amount: `${max_gas}`});
  const signedTxn = await client.signTransaction(account, txnRequest);
  const txnResult = await client.submitTransaction(signedTxn);
  await client.waitForTransaction(txnResult.hash);
  const txDetails = (await client.getTransactionByHash(txnResult.hash)) as Types.UserTransaction;
  console.log(txDetails);
}

const program = new Command();

program
  .name('move-ts-cli')
  .description('Move TS CLI generated by move-to-ts')
  .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
  .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default')


const aggregatorv3_initialize = async () => {
  const {client, account} = readConfig(program);

  const payload = Hippo_aggregator.Aggregatorv3.buildPayload_initialize();
  await sendPayloadTx(client, account, payload);
}

program
  .command("aggregatorv3:initialize")
  .description("")

  .action(aggregatorv3_initialize);


const aggregatorv3_one_step_route = async (X: string, Y: string, E: string, first_dex_type: string, first_pool_type: string, first_is_x_to_y: string, x_in: string, y_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const E_ = parseTypeTagOrThrow(E);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_aggregator.Aggregatorv3.buildPayload_one_step_route(first_dex_type_, first_pool_type_, first_is_x_to_y_, x_in_, y_min_out_, [X_, Y_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("aggregatorv3:one-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_E>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<x_in>')
  .argument('<y_min_out>')
  .action(aggregatorv3_one_step_route);


const aggregatorv3_three_step_route = async (X: string, Y: string, Z: string, M: string, E1: string, E2: string, E3: string, first_dex_type: string, first_pool_type: string, first_is_x_to_y: string, second_dex_type: string, second_pool_type: string, second_is_x_to_y: string, third_dex_type: string, third_pool_type: string, third_is_x_to_y: string, x_in: string, m_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const M_ = parseTypeTagOrThrow(M);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u8(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const m_min_out_ = u64(m_min_out);
  const payload = Hippo_aggregator.Aggregatorv3.buildPayload_three_step_route(first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, third_dex_type_, third_pool_type_, third_is_x_to_y_, x_in_, m_min_out_, [X_, Y_, Z_, M_, E1_, E2_, E3_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("aggregatorv3:three-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_M>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<third_dex_type>')
  .argument('<third_pool_type>')
  .argument('<third_is_x_to_y>')
  .argument('<x_in>')
  .argument('<m_min_out>')
  .action(aggregatorv3_three_step_route);


const aggregatorv3_two_step_route = async (X: string, Y: string, Z: string, E1: string, E2: string, first_dex_type: string, first_pool_type: string, first_is_x_to_y: string, second_dex_type: string, second_pool_type: string, second_is_x_to_y: string, x_in: string, z_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const z_min_out_ = u64(z_min_out);
  const payload = Hippo_aggregator.Aggregatorv3.buildPayload_two_step_route(first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, x_in_, z_min_out_, [X_, Y_, Z_, E1_, E2_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("aggregatorv3:two-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<x_in>')
  .argument('<z_min_out>')
  .action(aggregatorv3_two_step_route);


const coin_registry_add_token_script = async (TokenType: string, name: string, symbol: string, description: string, decimals: string, logo_url: string, project_url: string) => {
  const {client, account} = readConfig(program);
  const TokenType_ = parseTypeTagOrThrow(TokenType);
  const name_ = strToU8(name);
  const symbol_ = strToU8(symbol);
  const description_ = strToU8(description);
  const decimals_ = u8(decimals);
  const logo_url_ = strToU8(logo_url);
  const project_url_ = strToU8(project_url);
  const payload = Coin_registry.Coin_registry.buildPayload_add_token_script(name_, symbol_, description_, decimals_, logo_url_, project_url_, [TokenType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("coin_registry:add-token-script")
  .description("Add new token into registry")
  .argument('<TYPE_TokenType>')
  .argument('<name>')
  .argument('<symbol>')
  .argument('<description>')
  .argument('<decimals>')
  .argument('<logo_url>')
  .argument('<project_url>')
  .action(coin_registry_add_token_script);


const coin_registry_delist_token_script = async (symbol: string) => {
  const {client, account} = readConfig(program);
  const symbol_ = strToU8(symbol);
  const payload = Coin_registry.Coin_registry.buildPayload_delist_token_script(symbol_);
  await sendPayloadTx(client, account, payload);
}

program
  .command("coin_registry:delist-token-script")
  .description("Delist token")
  .argument('<symbol>')
  .action(coin_registry_delist_token_script);


const coin_registry_initialize_script = async () => {
  const {client, account} = readConfig(program);

  const payload = Coin_registry.Coin_registry.buildPayload_initialize_script();
  await sendPayloadTx(client, account, payload);
}

program
  .command("coin_registry:initialize-script")
  .description("Create token registry for signer")

  .action(coin_registry_initialize_script);


const coin_registry_update_token_info_script = async (symbol: string, description: string, logo_url: string, project_url: string) => {
  const {client, account} = readConfig(program);
  const symbol_ = strToU8(symbol);
  const description_ = strToU8(description);
  const logo_url_ = strToU8(logo_url);
  const project_url_ = strToU8(project_url);
  const payload = Coin_registry.Coin_registry.buildPayload_update_token_info_script(symbol_, description_, logo_url_, project_url_);
  await sendPayloadTx(client, account, payload);
}

program
  .command("coin_registry:update-token-info-script")
  .description("Update registry info of existing token")
  .argument('<symbol>')
  .argument('<description>')
  .argument('<logo_url>')
  .argument('<project_url>')
  .action(coin_registry_update_token_info_script);


const cp_scripts_add_liquidity_script = async (X: string, Y: string, amount_x: string, amount_y: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const amount_x_ = u64(amount_x);
  const amount_y_ = u64(amount_y);
  const payload = Hippo_swap.Cp_scripts.buildPayload_add_liquidity_script(amount_x_, amount_y_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("cp_scripts:add-liquidity-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<amount_x>')
  .argument('<amount_y>')
  .action(cp_scripts_add_liquidity_script);


const cp_scripts_create_new_pool_script = async (X: string, Y: string, fee_to: string, fee_on: string, lp_name: string, lp_symbol: string, lp_description: string, lp_logo_url: string, lp_project_url: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const fee_to_ = new HexString(fee_to);
  const fee_on_ = fee_on=='true';
  const lp_name_ = strToU8(lp_name);
  const lp_symbol_ = strToU8(lp_symbol);
  const lp_description_ = strToU8(lp_description);
  const lp_logo_url_ = strToU8(lp_logo_url);
  const lp_project_url_ = strToU8(lp_project_url);
  const payload = Hippo_swap.Cp_scripts.buildPayload_create_new_pool_script(fee_to_, fee_on_, lp_name_, lp_symbol_, lp_description_, lp_logo_url_, lp_project_url_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("cp_scripts:create-new-pool-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<fee_to>')
  .argument('<fee_on>')
  .argument('<lp_name>')
  .argument('<lp_symbol>')
  .argument('<lp_description>')
  .argument('<lp_logo_url>')
  .argument('<lp_project_url>')
  .action(cp_scripts_create_new_pool_script);


const cp_scripts_remove_liquidity_script = async (X: string, Y: string, liquidity: string, amount_x_min: string, amount_y_min: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const liquidity_ = u64(liquidity);
  const amount_x_min_ = u64(amount_x_min);
  const amount_y_min_ = u64(amount_y_min);
  const payload = Hippo_swap.Cp_scripts.buildPayload_remove_liquidity_script(liquidity_, amount_x_min_, amount_y_min_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("cp_scripts:remove-liquidity-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<liquidity>')
  .argument('<amount_x_min>')
  .argument('<amount_y_min>')
  .action(cp_scripts_remove_liquidity_script);


const cp_scripts_swap_script = async (X: string, Y: string, x_in: string, y_in: string, x_min_out: string, y_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const x_in_ = u64(x_in);
  const y_in_ = u64(y_in);
  const x_min_out_ = u64(x_min_out);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_swap.Cp_scripts.buildPayload_swap_script(x_in_, y_in_, x_min_out_, y_min_out_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("cp_scripts:swap-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<x_in>')
  .argument('<y_in>')
  .argument('<x_min_out>')
  .argument('<y_min_out>')
  .action(cp_scripts_swap_script);


const mock_coin_faucet_mint_to_script = async (TokenType: string, amount: string) => {
  const {client, account} = readConfig(program);
  const TokenType_ = parseTypeTagOrThrow(TokenType);
  const amount_ = u64(amount);
  const payload = Hippo_swap.Mock_coin.buildPayload_faucet_mint_to_script(amount_, [TokenType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("mock_coin:faucet-mint-to-script")
  .description("")
  .argument('<TYPE_TokenType>')
  .argument('<amount>')
  .action(mock_coin_faucet_mint_to_script);


const piece_swap_script_add_liquidity_script = async (X: string, Y: string, amount_x: string, amount_y: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const amount_x_ = u64(amount_x);
  const amount_y_ = u64(amount_y);
  const payload = Hippo_swap.Piece_swap_script.buildPayload_add_liquidity_script(amount_x_, amount_y_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("piece_swap_script:add-liquidity-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<amount_x>')
  .argument('<amount_y>')
  .action(piece_swap_script_add_liquidity_script);


const piece_swap_script_create_new_pool_script = async (X: string, Y: string, lp_name: string, lp_symbol: string, k: string, w1_numerator: string, w1_denominator: string, w2_numerator: string, w2_denominator: string, swap_fee_per_million: string, protocol_fee_share_per_thousand: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const lp_name_ = strToU8(lp_name);
  const lp_symbol_ = strToU8(lp_symbol);
  const k_ = u128(k);
  const w1_numerator_ = u128(w1_numerator);
  const w1_denominator_ = u128(w1_denominator);
  const w2_numerator_ = u128(w2_numerator);
  const w2_denominator_ = u128(w2_denominator);
  const swap_fee_per_million_ = u64(swap_fee_per_million);
  const protocol_fee_share_per_thousand_ = u64(protocol_fee_share_per_thousand);
  const payload = Hippo_swap.Piece_swap_script.buildPayload_create_new_pool_script(lp_name_, lp_symbol_, k_, w1_numerator_, w1_denominator_, w2_numerator_, w2_denominator_, swap_fee_per_million_, protocol_fee_share_per_thousand_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("piece_swap_script:create-new-pool-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<lp_name>')
  .argument('<lp_symbol>')
  .argument('<k>')
  .argument('<w1_numerator>')
  .argument('<w1_denominator>')
  .argument('<w2_numerator>')
  .argument('<w2_denominator>')
  .argument('<swap_fee_per_million>')
  .argument('<protocol_fee_share_per_thousand>')
  .action(piece_swap_script_create_new_pool_script);


const piece_swap_script_mock_deploy_script = async () => {
  const {client, account} = readConfig(program);

  const payload = Hippo_swap.Piece_swap_script.buildPayload_mock_deploy_script();
  await sendPayloadTx(client, account, payload);
}

program
  .command("piece_swap_script:mock-deploy-script")
  .description("")

  .action(piece_swap_script_mock_deploy_script);


const piece_swap_script_remove_liquidity_script = async (X: string, Y: string, liquidity: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const liquidity_ = u64(liquidity);
  const payload = Hippo_swap.Piece_swap_script.buildPayload_remove_liquidity_script(liquidity_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("piece_swap_script:remove-liquidity-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<liquidity>')
  .action(piece_swap_script_remove_liquidity_script);


const piece_swap_script_swap_script = async (X: string, Y: string, x_in: string, y_in: string, x_min_out: string, y_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const x_in_ = u64(x_in);
  const y_in_ = u64(y_in);
  const x_min_out_ = u64(x_min_out);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_swap.Piece_swap_script.buildPayload_swap_script(x_in_, y_in_, x_min_out_, y_min_out_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("piece_swap_script:swap-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<x_in>')
  .argument('<y_in>')
  .argument('<x_min_out>')
  .argument('<y_min_out>')
  .action(piece_swap_script_swap_script);


const router_three_step_route_script = async (X: string, Y: string, Z: string, A: string, first_pool_type: string, first_is_x_to_y: string, second_pool_type: string, second_is_x_to_y: string, third_pool_type: string, third_is_x_to_y: string, x_in: string, a_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const A_ = parseTypeTagOrThrow(A);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const third_pool_type_ = u8(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const a_min_out_ = u64(a_min_out);
  const payload = Hippo_swap.Router.buildPayload_three_step_route_script(first_pool_type_, first_is_x_to_y_, second_pool_type_, second_is_x_to_y_, third_pool_type_, third_is_x_to_y_, x_in_, a_min_out_, [X_, Y_, Z_, A_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("router:three-step-route-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_A>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<third_pool_type>')
  .argument('<third_is_x_to_y>')
  .argument('<x_in>')
  .argument('<a_min_out>')
  .action(router_three_step_route_script);


const router_two_step_route_script = async (X: string, Y: string, Z: string, first_pool_type: string, first_is_x_to_y: string, second_pool_type: string, second_is_x_to_y: string, x_in: string, z_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const first_pool_type_ = u8(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_pool_type_ = u8(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const z_min_out_ = u64(z_min_out);
  const payload = Hippo_swap.Router.buildPayload_two_step_route_script(first_pool_type_, first_is_x_to_y_, second_pool_type_, second_is_x_to_y_, x_in_, z_min_out_, [X_, Y_, Z_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("router:two-step-route-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<x_in>')
  .argument('<z_min_out>')
  .action(router_two_step_route_script);


const stable_curve_scripts_add_liquidity = async (X: string, Y: string, amount_x: string, amount_y: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const amount_x_ = u64(amount_x);
  const amount_y_ = u64(amount_y);
  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_add_liquidity(amount_x_, amount_y_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("stable_curve_scripts:add-liquidity")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<amount_x>')
  .argument('<amount_y>')
  .action(stable_curve_scripts_add_liquidity);


const stable_curve_scripts_mock_deploy_script = async () => {
  const {client, account} = readConfig(program);

  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_mock_deploy_script();
  await sendPayloadTx(client, account, payload);
}

program
  .command("stable_curve_scripts:mock-deploy-script")
  .description("")

  .action(stable_curve_scripts_mock_deploy_script);


const stable_curve_scripts_remove_liquidity = async (X: string, Y: string, liquidity: string, min_amount_x: string, min_amount_y: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const liquidity_ = u64(liquidity);
  const min_amount_x_ = u64(min_amount_x);
  const min_amount_y_ = u64(min_amount_y);
  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_remove_liquidity(liquidity_, min_amount_x_, min_amount_y_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("stable_curve_scripts:remove-liquidity")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<liquidity>')
  .argument('<min_amount_x>')
  .argument('<min_amount_y>')
  .action(stable_curve_scripts_remove_liquidity);


const stable_curve_scripts_swap_script = async (X: string, Y: string, x_in: string, y_in: string, x_min_out: string, y_min_out: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const x_in_ = u64(x_in);
  const y_in_ = u64(y_in);
  const x_min_out_ = u64(x_min_out);
  const y_min_out_ = u64(y_min_out);
  const payload = Hippo_swap.Stable_curve_scripts.buildPayload_swap_script(x_in_, y_in_, x_min_out_, y_min_out_, [X_, Y_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("stable_curve_scripts:swap-script")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<x_in>')
  .argument('<y_in>')
  .argument('<x_min_out>')
  .argument('<y_min_out>')
  .action(stable_curve_scripts_swap_script);


const coins_init_coin_types = async () => {
  const {client, account} = readConfig(program);

  const payload = Econia.Coins.buildPayload_init_coin_types();
  await sendPayloadTx(client, account, payload);
}

program
  .command("coins:init-coin-types")
  .description("")

  .action(coins_init_coin_types);


const coins_mint = async (CoinType: string, amount: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const payload = Econia.Coins.buildPayload_mint(amount_, [CoinType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("coins:mint")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<amount>')
  .action(coins_mint);


const init_init_econia = async () => {
  const {client, account} = readConfig(program);

  const payload = Econia.Init.buildPayload_init_econia();
  await sendPayloadTx(client, account, payload);
}

program
  .command("init:init-econia")
  .description("")

  .action(init_init_econia);


const market_cancel_limit_order_user = async (B: string, Q: string, E: string, host: string, side: string, order_id: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const side_ = side=='true';
  const order_id_ = u128(order_id);
  const payload = Econia.Market.buildPayload_cancel_limit_order_user(host_, side_, order_id_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:cancel-limit-order-user")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<host>')
  .argument('<side>')
  .argument('<order_id>')
  .action(market_cancel_limit_order_user);


const market_fill_market_order_user = async (B: string, Q: string, E: string, host: string, style: string, max_base_parcels: string, max_quote_units: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const style_ = style=='true';
  const max_base_parcels_ = u64(max_base_parcels);
  const max_quote_units_ = u64(max_quote_units);
  const payload = Econia.Market.buildPayload_fill_market_order_user(host_, style_, max_base_parcels_, max_quote_units_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:fill-market-order-user")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<host>')
  .argument('<style>')
  .argument('<max_base_parcels>')
  .argument('<max_quote_units>')
  .action(market_fill_market_order_user);


const market_place_limit_order_user = async (B: string, Q: string, E: string, host: string, side: string, base_parcels: string, price: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const host_ = new HexString(host);
  const side_ = side=='true';
  const base_parcels_ = u64(base_parcels);
  const price_ = u64(price);
  const payload = Econia.Market.buildPayload_place_limit_order_user(host_, side_, base_parcels_, price_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:place-limit-order-user")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<host>')
  .argument('<side>')
  .argument('<base_parcels>')
  .argument('<price>')
  .action(market_place_limit_order_user);


const market_register_market = async (B: string, Q: string, E: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const payload = Econia.Market.buildPayload_register_market([B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:register-market")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .action(market_register_market);


const user_register_market_account = async (B: string, Q: string, E: string, custodian_id: string) => {
  const {client, account} = readConfig(program);
  const B_ = parseTypeTagOrThrow(B);
  const Q_ = parseTypeTagOrThrow(Q);
  const E_ = parseTypeTagOrThrow(E);
  const custodian_id_ = u64(custodian_id);
  const payload = Econia.User.buildPayload_register_market_account(custodian_id_, [B_, Q_, E_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:register-market-account")
  .description("")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<custodian_id>')
  .action(user_register_market_account);



const book_orders_sdk = async (owner: string, B: string, Q: string, E: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.book_orders_sdk());
}

program
  .command("book-orders-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .action(book_orders_sdk)


const book_price_levels_sdk = async (owner: string, B: string, Q: string, E: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.book_price_levels_sdk());
}

program
  .command("book-price-levels-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .action(book_price_levels_sdk)


const simulate_swap_sdk = async (owner: string, B: string, Q: string, E: string, style: string, coins_in: string) => {
  const {client} = readConfig(program);
  const repo = getProjectRepo();
  const owner_ = new HexString(owner);
  const value = await Econia.Market.OrderBook.load(repo, client, owner_, [parseTypeTagOrThrow(B), parseTypeTagOrThrow(Q), parseTypeTagOrThrow(E)])
  print(value.simulate_swap_sdk(style=='true', u64(coins_in)));
}

program
  .command("simulate-swap-sdk")
  .argument("<ADDRESS:owner>")
  .argument('<TYPE_B>')
  .argument('<TYPE_Q>')
  .argument('<TYPE_E>')
  .argument('<style>')
  .argument('<coins_in>')
  .action(simulate_swap_sdk)


program.parse();
